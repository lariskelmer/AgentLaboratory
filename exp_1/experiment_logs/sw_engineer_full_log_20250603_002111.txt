=== SW_ENGINEER PROMPT LOG ===

Interaction 1:
('', 'Current Literature Review: Provided here is a literature review on this topic:\\narXiv ID: 2011.14808v1, Summary: This comprehensive survey paper discusses deep learning optimization techniques for edge computing systems. It covers four main approaches: (1) hand-crafted lightweight models like MobileNet and EfficientNet, (2) model compression methods including pruning and quantization, (3) hardware-aware neural architecture search, and (4) adaptive deep learning models. The paper provides detailed comparisons of different techniques and their tradeoffs between accuracy and efficiency. Experimental results show these optimization methods can significantly reduce model size and computational complexity while maintaining competitive accuracy, making them suitable for resource-constrained edge devices.\\narXiv ID: 2108.09343v2, Summary: This paper proposes an early-exit DNN architecture with expert branches specialized for different image distortion types (blur and noise) to improve edge offloading efficiency. The key innovation is using a distortion classifier to select appropriate expert branches at each exit point, enabling more accurate early classification on edge devices. Experiments show the approach increases edge classification probability by 10-20% for distorted images while maintaining accuracy, reducing end-to-end latency by up to 30% compared to standard early-exit DNNs. The method is evaluated on Amazon EC2 instances across different geographic locations, demonstrating robustness under varying network conditions. The work provides important insights for optimizing real-time image classification on resource-constrained edge devices handling distorted inputs.\\narXiv ID: 2111.14243v1, Summary: EffCNet is an efficient version of CondenseNet designed for edge devices, utilizing depthwise separable convolutions and self-querying data augmentation to improve real-time inference performance. The paper demonstrates significant reductions in model size (from 16.7MB to 2.1MB for CIFAR-10), FLOPs (from 65.82M to 61.01M), and parameters while maintaining competitive accuracy (94.15% top-1 on CIFAR-10). The architecture was successfully deployed on NXP BlueBox 2.0, an edge platform for autonomous vehicles, showing practical applicability for resource-constrained environments.\\narXiv ID: 2502.10047v1, Summary: This paper presents Janus, a novel framework for low-latency cloud-device collaborative Vision Transformer (ViT) inference over dynamic networks. The key innovation is combining token pruning techniques with a fine-to-coarse model splitting policy to enable efficient ViT execution across edge and cloud resources. Janus dynamically selects optimal pruning levels and split points based on network conditions, achieving up to 5.15x throughput improvement and reducing latency violations by up to 98.7% compared to baselines while maintaining accuracy. The system includes a lightweight profiler for latency prediction and a dynamic scheduler for real-time configuration. Experimental results demonstrate Janus\\'s effectiveness across image recognition and video classification tasks under various network conditions.\\narXiv ID: 2404.10407v1, Summary: This comprehensive survey paper evaluates four primary model compression techniques (quantization, low-rank approximation, knowledge distillation, and pruning) for optimizing Vision Transformers (ViTs) for edge deployment. Through extensive experiments on CIFAR datasets, the authors demonstrate that post-training quantization and knowledge distillation achieve the best trade-offs, reducing model size by 4x while maintaining accuracy. The paper also explores hybrid approaches, showing that combining quantization with knowledge distillation can double inference speed while reducing model size to 25% of original. Key findings include: 1) Dynamic quantization reduces ViT size to 84MB (from 327MB) with minimal accuracy drop (98.73% vs 98.94% on CIFAR-10), 2) DeiT tiny achieves 16.78 iterations/sec (vs 4.48 for vanilla ViT) with 95.43% accuracy, and 3) Hybrid approaches combining quantization and distillation achieve 2x speedup with manageable accuracy trade-offs.\\narXiv ID: 2303.08810v1, Summary: BiFormer introduces a novel bi-level routing attention (BRA) mechanism for vision transformers that enables dynamic, query-aware sparsity. BRA first filters irrelevant key-value pairs at a coarse region level (region-to-region routing) before applying fine-grained token-to-token attention in the remaining regions. This approach achieves O((HW)^(4/3)) complexity with proper region partitioning while maintaining global receptive fields. The authors demonstrate state-of-the-art performance on ImageNet classification (83.8% top-1 accuracy for BiFormer-S), COCO object detection (47.1 mAP for BiFormer-B), and ADE20K semantic segmentation (49.9 mIoU for BiFormer-B). The method shows particular strength in preserving fine-grained details for small object detection, with BiFormer-S achieving 30.2 APs on COCO compared to 29.2 for WaveViT-S.\\narXiv ID: 2212.02687v3, Summary: This paper investigates dynamic inference techniques for vision transformers to enable efficient execution under varying resource constraints. Key findings include: (1) Convolutions dominate FLOPs in modern vision transformers (68-89%), not attention layers, due to integrated convolutions for accuracy/performance. (2) FLOP distribution poorly predicts GPU runtime due to optimized convolution execution. (3) Models show varying resilience to pruning - SegFormer achieves 28% energy savings with 1.4% accuracy drop without retraining, while ResNet-50 (via OFA) achieves 53% energy savings with 3.3% accuracy drop. The work provides insights for designing efficient vision transformers and dynamic execution strategies for edge deployment.\\narXiv ID: 2405.00906v1, Summary: LOTUS introduces a novel method combining data lottery ticket selection and sparsity pruning to accelerate vision transformer training while maintaining accuracy. The approach identifies informative data subsets and eliminates redundant parameters through a three-phase process: (1) attention-map-based data lottery ticket identification, (2) Instant Sparse Soup Pruning (ISSP) for model compression, and (3) fine-tuning. Experiments show rapid convergence (reaching near-SOTA performance by 5 epochs) and maintain 79% accuracy at 30% sparsity on CIFAR-10, though ISSP showed accuracy drops due to aggressive pruning. The work demonstrates promising directions for efficient transformer training through combined data and model optimization.\\narXiv ID: 2111.15667v3, Summary: This paper introduces Adaptive Token Sampler (ATS), a parameter-free module for dynamically reducing the number of tokens in vision transformers based on input content. ATS uses attention weights to score token importance and performs inverse transform sampling to select significant tokens. Key results: 1) Reduces DeiT-S GFLOPs by 37% with only 0.1% accuracy drop on ImageNet; 2) Achieves 2x computational cost reduction while preserving accuracy on Kinetics-400/600; 3) Can be added to pre-trained models without fine-tuning. The method shows superior efficiency-accuracy trade-offs compared to DynamicViT and EViT.\\narXiv ID: 2408.08437v1, Summary: This paper presents PQV-Mobile, a combined pruning and quantization toolkit for optimizing Vision Transformers (ViTs) for mobile/edge deployment. Key contributions: 1) Supports multiple structured pruning methods (magnitude, Taylor, Hessian importance) and quantization (FP32 to FP16/int8); 2) Achieves 7.18x latency reduction with only 2.24% accuracy drop on DeiT models; 3) Provides hardware-aware optimizations for various backends (x86, FBGEMM, QNNPACK). Experimental results show superior latency-memory-accuracy tradeoffs compared to standalone compression methods.\\nPlan: Research Plan: "Adaptive Token-Head Co-Optimization for Edge ViTs" (ATHE)\\n\\n1. Novel Technique: \\n- Combines input-aware token pruning (ATS-like) with dynamic attention head routing\\n- Two-stage adaptation: (1) Lightweight CNN classifier categorizes input difficulty (simple/complex), (2) ViT dynamically adjusts:\\n   * Simple images: Aggressive token pruning (50-70%) + only basic attention heads\\n   * Complex images: Conservative pruning (20-30%) + all specialized heads\\n\\n2. Implementation:\\n- Base Model: DeiT-Tiny (5.7M params) modified with:\\n   * Input classifier (MobileNetV1 0.25x width)\\n   * Token importance scoring (learned linear layer)\\n   * Head importance scoring (attention entropy-based)\\n- Device: Raspberry Pi 4 (4GB) with PyTorch Lite\\n- Dataset: CIFAR-100 (resized to 224x224)\\n\\n3. Experiment:\\n- Baseline Comparisons: \\n   * Vanilla DeiT-Tiny\\n   * DynamicViT (token pruning only)\\n   * BiFormer (static sparse attention)\\n- Metrics:\\n   * Accuracy (top-1)\\n   * Latency (end-to-end inference)\\n   * Energy (measured via USB power monitor)\\n   * FLOPs reduction\\n- Evaluation Protocol:\\n   * 5 runs per configuration\\n   * Test on balanced subset (500 simple/complex images each)\\n\\n4. Expected Innovations:\\n- First joint optimization of tokens and heads based on input content\\n- Hardware-friendly implementation (minimal overhead for adaptation logic)\\n- Demonstrable 2-3x latency reduction vs baselines for simple images\\n\\n5. Timeline:\\nWeek 1-2: Model modifications\\nWeek 3: Baseline implementations\\nWeek 4: Profiling/measurements\\nWeek 5: Analysis/writeup', 'Current Plan: Research Plan: "Adaptive Token-Head Co-Optimization for Edge ViTs" (ATHE)\\n\\n1. Novel Technique: \\n- Combines input-aware token pruning (ATS-like) with dynamic attention head routing\\n- Two-stage adaptation: (1) Lightweight CNN classifier categorizes input difficulty (simple/complex), (2) ViT dynamically adjusts:\\n   * Simple images: Aggressive token pruning (50-70%) + only basic attention heads\\n   * Complex images: Conservative pruning (20-30%) + all specialized heads\\n\\n2. Implementation:\\n- Base Model: DeiT-Tiny (5.7M params) modified with:\\n   * Input classifier (MobileNetV1 0.25x width)\\n   * Token importance scoring (learned linear layer)\\n   * Head importance scoring (attention entropy-based)\\n- Device: Raspberry Pi 4 (4GB) with PyTorch Lite\\n- Dataset: CIFAR-100 (resized to 224x224)\\n\\n3. Experiment:\\n- Baseline Comparisons: \\n   * Vanilla DeiT-Tiny\\n   * DynamicViT (token pruning only)\\n   * BiFormer (static sparse attention)\\n- Metrics:\\n   * Accuracy (top-1)\\n   * Latency (end-to-end inference)\\n   * Energy (measured via USB power monitor)\\n   * FLOPs reduction\\n- Evaluation Protocol:\\n   * 5 runs per configuration\\n   * Test on balanced subset (500 simple/complex images each)\\n\\n4. Expected Innovations:\\n- First joint optimization of tokens and heads based on input content\\n- Hardware-friendly implementation (minimal overhead for adaptation logic)\\n- Demonstrable 2-3x latency reduction vs baselines for simple images\\n\\n5. Timeline:\\nWeek 1-2: Model modifications\\nWeek 3: Baseline implementations\\nWeek 4: Profiling/measurements\\nWeek 5: Analysis/writeup')\n~~~~~~~~~~\nHistory: \n~~~~~~~~~~\nCurrent Step #0, Phase: data preparation\n\n[Objective] Your goal is to perform research on the following topic: The goal is to design and evaluate a new technique for optimizing deep learning models for real-time image classification on resource-constrained edge devices, aiming to maximize accuracy while minimizing inference latency and power consumption.\nFeedback: \nFeedback from previous command: \n\nNotes: Notes for the task objective: [{'phases': ['data preparation'], 'note': 'Use a public, well-documented dataset for image classification, suitable for experimentation on edge devices (e.g. CIFAR-10, or a reduced/adapted version of a larger dataset).'}, {'phases': ['data preparation'], 'note': 'Describe all preprocessing and data augmentation steps necessary to improve training efficiency or inference quality on edge devices.'}, {'phases': ['data preparation'], 'note': 'Here is a sample code you can use to load CIFAR-10\\\\nfrom datasets import load_dataset\\\\ncifar10_test_set = load_dataset("cifar10")["test"]\\\\n# Para carregar o conjunto de treino, voc\xc3\xaa usaria:\\\\n# cifar10_train_set = load_dataset("cifar10")["train"]'}]\n\nYour previous command was: . Make sure your new output is very different.\nPlease produce a single command below:\n
==================================================
Interaction 2:
('', 'Current Literature Review: Provided here is a literature review on this topic:\\narXiv ID: 2011.14808v1, Summary: This comprehensive survey paper discusses deep learning optimization techniques for edge computing systems. It covers four main approaches: (1) hand-crafted lightweight models like MobileNet and EfficientNet, (2) model compression methods including pruning and quantization, (3) hardware-aware neural architecture search, and (4) adaptive deep learning models. The paper provides detailed comparisons of different techniques and their tradeoffs between accuracy and efficiency. Experimental results show these optimization methods can significantly reduce model size and computational complexity while maintaining competitive accuracy, making them suitable for resource-constrained edge devices.\\narXiv ID: 2108.09343v2, Summary: This paper proposes an early-exit DNN architecture with expert branches specialized for different image distortion types (blur and noise) to improve edge offloading efficiency. The key innovation is using a distortion classifier to select appropriate expert branches at each exit point, enabling more accurate early classification on edge devices. Experiments show the approach increases edge classification probability by 10-20% for distorted images while maintaining accuracy, reducing end-to-end latency by up to 30% compared to standard early-exit DNNs. The method is evaluated on Amazon EC2 instances across different geographic locations, demonstrating robustness under varying network conditions. The work provides important insights for optimizing real-time image classification on resource-constrained edge devices handling distorted inputs.\\narXiv ID: 2111.14243v1, Summary: EffCNet is an efficient version of CondenseNet designed for edge devices, utilizing depthwise separable convolutions and self-querying data augmentation to improve real-time inference performance. The paper demonstrates significant reductions in model size (from 16.7MB to 2.1MB for CIFAR-10), FLOPs (from 65.82M to 61.01M), and parameters while maintaining competitive accuracy (94.15% top-1 on CIFAR-10). The architecture was successfully deployed on NXP BlueBox 2.0, an edge platform for autonomous vehicles, showing practical applicability for resource-constrained environments.\\narXiv ID: 2502.10047v1, Summary: This paper presents Janus, a novel framework for low-latency cloud-device collaborative Vision Transformer (ViT) inference over dynamic networks. The key innovation is combining token pruning techniques with a fine-to-coarse model splitting policy to enable efficient ViT execution across edge and cloud resources. Janus dynamically selects optimal pruning levels and split points based on network conditions, achieving up to 5.15x throughput improvement and reducing latency violations by up to 98.7% compared to baselines while maintaining accuracy. The system includes a lightweight profiler for latency prediction and a dynamic scheduler for real-time configuration. Experimental results demonstrate Janus\\'s effectiveness across image recognition and video classification tasks under various network conditions.\\narXiv ID: 2404.10407v1, Summary: This comprehensive survey paper evaluates four primary model compression techniques (quantization, low-rank approximation, knowledge distillation, and pruning) for optimizing Vision Transformers (ViTs) for edge deployment. Through extensive experiments on CIFAR datasets, the authors demonstrate that post-training quantization and knowledge distillation achieve the best trade-offs, reducing model size by 4x while maintaining accuracy. The paper also explores hybrid approaches, showing that combining quantization with knowledge distillation can double inference speed while reducing model size to 25% of original. Key findings include: 1) Dynamic quantization reduces ViT size to 84MB (from 327MB) with minimal accuracy drop (98.73% vs 98.94% on CIFAR-10), 2) DeiT tiny achieves 16.78 iterations/sec (vs 4.48 for vanilla ViT) with 95.43% accuracy, and 3) Hybrid approaches combining quantization and distillation achieve 2x speedup with manageable accuracy trade-offs.\\narXiv ID: 2303.08810v1, Summary: BiFormer introduces a novel bi-level routing attention (BRA) mechanism for vision transformers that enables dynamic, query-aware sparsity. BRA first filters irrelevant key-value pairs at a coarse region level (region-to-region routing) before applying fine-grained token-to-token attention in the remaining regions. This approach achieves O((HW)^(4/3)) complexity with proper region partitioning while maintaining global receptive fields. The authors demonstrate state-of-the-art performance on ImageNet classification (83.8% top-1 accuracy for BiFormer-S), COCO object detection (47.1 mAP for BiFormer-B), and ADE20K semantic segmentation (49.9 mIoU for BiFormer-B). The method shows particular strength in preserving fine-grained details for small object detection, with BiFormer-S achieving 30.2 APs on COCO compared to 29.2 for WaveViT-S.\\narXiv ID: 2212.02687v3, Summary: This paper investigates dynamic inference techniques for vision transformers to enable efficient execution under varying resource constraints. Key findings include: (1) Convolutions dominate FLOPs in modern vision transformers (68-89%), not attention layers, due to integrated convolutions for accuracy/performance. (2) FLOP distribution poorly predicts GPU runtime due to optimized convolution execution. (3) Models show varying resilience to pruning - SegFormer achieves 28% energy savings with 1.4% accuracy drop without retraining, while ResNet-50 (via OFA) achieves 53% energy savings with 3.3% accuracy drop. The work provides insights for designing efficient vision transformers and dynamic execution strategies for edge deployment.\\narXiv ID: 2405.00906v1, Summary: LOTUS introduces a novel method combining data lottery ticket selection and sparsity pruning to accelerate vision transformer training while maintaining accuracy. The approach identifies informative data subsets and eliminates redundant parameters through a three-phase process: (1) attention-map-based data lottery ticket identification, (2) Instant Sparse Soup Pruning (ISSP) for model compression, and (3) fine-tuning. Experiments show rapid convergence (reaching near-SOTA performance by 5 epochs) and maintain 79% accuracy at 30% sparsity on CIFAR-10, though ISSP showed accuracy drops due to aggressive pruning. The work demonstrates promising directions for efficient transformer training through combined data and model optimization.\\narXiv ID: 2111.15667v3, Summary: This paper introduces Adaptive Token Sampler (ATS), a parameter-free module for dynamically reducing the number of tokens in vision transformers based on input content. ATS uses attention weights to score token importance and performs inverse transform sampling to select significant tokens. Key results: 1) Reduces DeiT-S GFLOPs by 37% with only 0.1% accuracy drop on ImageNet; 2) Achieves 2x computational cost reduction while preserving accuracy on Kinetics-400/600; 3) Can be added to pre-trained models without fine-tuning. The method shows superior efficiency-accuracy trade-offs compared to DynamicViT and EViT.\\narXiv ID: 2408.08437v1, Summary: This paper presents PQV-Mobile, a combined pruning and quantization toolkit for optimizing Vision Transformers (ViTs) for mobile/edge deployment. Key contributions: 1) Supports multiple structured pruning methods (magnitude, Taylor, Hessian importance) and quantization (FP32 to FP16/int8); 2) Achieves 7.18x latency reduction with only 2.24% accuracy drop on DeiT models; 3) Provides hardware-aware optimizations for various backends (x86, FBGEMM, QNNPACK). Experimental results show superior latency-memory-accuracy tradeoffs compared to standalone compression methods.\\nPlan: Research Plan: "Adaptive Token-Head Co-Optimization for Edge ViTs" (ATHE)\\n\\n1. Novel Technique: \\n- Combines input-aware token pruning (ATS-like) with dynamic attention head routing\\n- Two-stage adaptation: (1) Lightweight CNN classifier categorizes input difficulty (simple/complex), (2) ViT dynamically adjusts:\\n   * Simple images: Aggressive token pruning (50-70%) + only basic attention heads\\n   * Complex images: Conservative pruning (20-30%) + all specialized heads\\n\\n2. Implementation:\\n- Base Model: DeiT-Tiny (5.7M params) modified with:\\n   * Input classifier (MobileNetV1 0.25x width)\\n   * Token importance scoring (learned linear layer)\\n   * Head importance scoring (attention entropy-based)\\n- Device: Raspberry Pi 4 (4GB) with PyTorch Lite\\n- Dataset: CIFAR-100 (resized to 224x224)\\n\\n3. Experiment:\\n- Baseline Comparisons: \\n   * Vanilla DeiT-Tiny\\n   * DynamicViT (token pruning only)\\n   * BiFormer (static sparse attention)\\n- Metrics:\\n   * Accuracy (top-1)\\n   * Latency (end-to-end inference)\\n   * Energy (measured via USB power monitor)\\n   * FLOPs reduction\\n- Evaluation Protocol:\\n   * 5 runs per configuration\\n   * Test on balanced subset (500 simple/complex images each)\\n\\n4. Expected Innovations:\\n- First joint optimization of tokens and heads based on input content\\n- Hardware-friendly implementation (minimal overhead for adaptation logic)\\n- Demonstrable 2-3x latency reduction vs baselines for simple images\\n\\n5. Timeline:\\nWeek 1-2: Model modifications\\nWeek 3: Baseline implementations\\nWeek 4: Profiling/measurements\\nWeek 5: Analysis/writeup', 'Current Plan: Research Plan: "Adaptive Token-Head Co-Optimization for Edge ViTs" (ATHE)\\n\\n1. Novel Technique: \\n- Combines input-aware token pruning (ATS-like) with dynamic attention head routing\\n- Two-stage adaptation: (1) Lightweight CNN classifier categorizes input difficulty (simple/complex), (2) ViT dynamically adjusts:\\n   * Simple images: Aggressive token pruning (50-70%) + only basic attention heads\\n   * Complex images: Conservative pruning (20-30%) + all specialized heads\\n\\n2. Implementation:\\n- Base Model: DeiT-Tiny (5.7M params) modified with:\\n   * Input classifier (MobileNetV1 0.25x width)\\n   * Token importance scoring (learned linear layer)\\n   * Head importance scoring (attention entropy-based)\\n- Device: Raspberry Pi 4 (4GB) with PyTorch Lite\\n- Dataset: CIFAR-100 (resized to 224x224)\\n\\n3. Experiment:\\n- Baseline Comparisons: \\n   * Vanilla DeiT-Tiny\\n   * DynamicViT (token pruning only)\\n   * BiFormer (static sparse attention)\\n- Metrics:\\n   * Accuracy (top-1)\\n   * Latency (end-to-end inference)\\n   * Energy (measured via USB power monitor)\\n   * FLOPs reduction\\n- Evaluation Protocol:\\n   * 5 runs per configuration\\n   * Test on balanced subset (500 simple/complex images each)\\n\\n4. Expected Innovations:\\n- First joint optimization of tokens and heads based on input content\\n- Hardware-friendly implementation (minimal overhead for adaptation logic)\\n- Demonstrable 2-3x latency reduction vs baselines for simple images\\n\\n5. Timeline:\\nWeek 1-2: Model modifications\\nWeek 3: Baseline implementations\\nWeek 4: Profiling/measurements\\nWeek 5: Analysis/writeup')\n~~~~~~~~~~\nHistory: Step #0, Phase: data preparation, Feedback: \nFeedback from previous command: \n, Your response: ```DIALOGUE\nLet's start by loading the CIFAR-100 dataset from HuggingFace as specified in the plan. We'll need to resize the images to 224x224 for DeiT compatibility. Would you like me to proceed with loading and resizing the dataset using a simple pipeline?\n```\n~~~~~~~~~~\nCurrent Step #1, Phase: data preparation\n\n[Objective] Your goal is to perform research on the following topic: The goal is to design and evaluate a new technique for optimizing deep learning models for real-time image classification on resource-constrained edge devices, aiming to maximize accuracy while minimizing inference latency and power consumption.\nFeedback: \nFeedback from previous command: \nHF search command produced by the ML agent:\nCIFAR-100Feedback provided to the ML agent: Huggingface results: Dataset ID: cifar100\nDescription: The CIFAR-100 dataset consists of 60000 32x32 colour images in 100 classes, with 600 images\nper class. There are 500 training images and 100 testing images per class. There are 50000 training images and 10000 test images. The 100 classes are grouped into 20 superclasses.\nThere are two labels per image - fine label (actual class) and coarse label (superclass).\nLikes: 6\nDownloads: 3516\nHas Testing Set: True\nHas Training Set: True\nTest Download Size: 21.6M\nTest Dataset Size: 10000\nTrain Download Size: 107.5M\nTrain Dataset Size: 50000\n\nDataset ID: opus100\nDescription: OPUS-100 is English-centric, meaning that all training pairs include English on either the source or target side.\nThe corpus covers 100 languages (including English).OPUS-100 contains approximately 55M sentence pairs.\nOf the 99 language pairs, 44 have 1M sentence pairs of training data, 73 have at least 100k, and 95 have at least 10k.\nLikes: 19\nDownloads: 19200\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: cifar10\nDescription: The CIFAR-10 dataset consists of 60000 32x32 colour images in 10 classes, with 6000 images\nper class. There are 50000 training images and 10000 test images.\nLikes: 14\nDownloads: 23528\nHas Testing Set: True\nHas Training Set: True\nTest Download Size: 21.7M\nTest Dataset Size: 10000\nTrain Download Size: 108.6M\nTrain Dataset Size: 50000\n\nDataset ID: wikitext\nDescription:  The WikiText language modeling dataset is a collection of over 100 million tokens extracted from the set of verified\n Good and Featured articles on Wikipedia. The dataset is available under the Creative Commons Attribution-ShareAlike\n License.\nLikes: 116\nDownloads: 275669\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: race\nDescription: Race is a large-scale reading comprehension dataset with more than 28,000 passages and nearly 100,000 questions. The\n dataset is collected from English examinations in China, which are designed for middle school and high school students.\nThe dataset can be served as the training and test sets for machine comprehension.\nLikes: 14\nDownloads: 46623\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: google_wellformed_query\nDescription: Google's query wellformedness dataset was created by crowdsourcing well-formedness annotations for 25,100 queries from the Paralex corpus. Every query was annotated by five raters each with 1/0 rating of whether or not the query is well-formed.\nLikes: 5\nDownloads: 1036\nHas Testing Set: True\nHas Training Set: True\nTest Download Size: 185.1K\nTest Dataset Size: 3850\nTrain Download Size: 837.3K\nTrain Dataset Size: 17500\n\nDataset ID: wiki_dpr\nDescription: This is the wikipedia split used to evaluate the Dense Passage Retrieval (DPR) model.\nIt contains 21M passages from wikipedia along with their DPR embeddings.\nThe wikipedia articles were split into multiple, disjoint text blocks of 100 words as passages.\nLikes: 11\nDownloads: 6942\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: squad_v2\nDescription: combines the 100,000 questions in SQuAD1.1 with over 50,000 unanswerable questions written adversarially by crowdworkers\n to look similar to answerable ones. To do well on SQuAD2.0, systems must not only answer questions when possible, but\n also determine when no answer is supported by the paragraph and abstain from answering.\nLikes: 27\nDownloads: 41619\nHas Testing Set: False\nHas Training Set: True\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: 111.3M\nTrain Dataset Size: 130319\n\nDataset ID: alkzar90/NIH-Chest-X-ray-dataset\nDescription: The NIH Chest X-ray dataset consists of 100,000 de-identified images of chest x-rays. The images are in PNG format.\n\nThe data is provided by the NIH Clinical Center and is available through the NIH download site: https://nihcc.app.box.com/v/ChestXray-NIHCC\nLikes: 9\nDownloads: 52\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: ubuntu_dialogs_corpus\nDescription: Ubuntu Dialogue Corpus, a dataset containing almost 1 million multi-turn dialogues, with a total of over 7 million utterances and 100 million words. This provides a unique resource for research into building dialogue managers based on neural language models that can make use of large amounts of unlabeled data. The dataset has both the multi-turn property of conversations in the Dialog State Tracking Challenge datasets, and the unstructured nature of interactions from microblog services such as Twitter.\nLikes: 8\nDownloads: 441\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\n\nNotes: Notes for the task objective: [{'phases': ['data preparation'], 'note': 'Use a public, well-documented dataset for image classification, suitable for experimentation on edge devices (e.g. CIFAR-10, or a reduced/adapted version of a larger dataset).'}, {'phases': ['data preparation'], 'note': 'Describe all preprocessing and data augmentation steps necessary to improve training efficiency or inference quality on edge devices.'}, {'phases': ['data preparation'], 'note': 'Here is a sample code you can use to load CIFAR-10\\\\nfrom datasets import load_dataset\\\\ncifar10_test_set = load_dataset("cifar10")["test"]\\\\n# Para carregar o conjunto de treino, voc\xc3\xaa usaria:\\\\n# cifar10_train_set = load_dataset("cifar10")["train"]'}]\n\nYour previous command was: ```DIALOGUE\nLet's start by loading the CIFAR-100 dataset from HuggingFace as specified in the plan. We'll need to resize the images to 224x224 for DeiT compatibility. Would you like me to proceed with loading and resizing the dataset using a simple pipeline?\n```. Make sure your new output is very different.\nPlease produce a single command below:\n
==================================================
Interaction 3:
('', 'Current Literature Review: Provided here is a literature review on this topic:\\narXiv ID: 2011.14808v1, Summary: This comprehensive survey paper discusses deep learning optimization techniques for edge computing systems. It covers four main approaches: (1) hand-crafted lightweight models like MobileNet and EfficientNet, (2) model compression methods including pruning and quantization, (3) hardware-aware neural architecture search, and (4) adaptive deep learning models. The paper provides detailed comparisons of different techniques and their tradeoffs between accuracy and efficiency. Experimental results show these optimization methods can significantly reduce model size and computational complexity while maintaining competitive accuracy, making them suitable for resource-constrained edge devices.\\narXiv ID: 2108.09343v2, Summary: This paper proposes an early-exit DNN architecture with expert branches specialized for different image distortion types (blur and noise) to improve edge offloading efficiency. The key innovation is using a distortion classifier to select appropriate expert branches at each exit point, enabling more accurate early classification on edge devices. Experiments show the approach increases edge classification probability by 10-20% for distorted images while maintaining accuracy, reducing end-to-end latency by up to 30% compared to standard early-exit DNNs. The method is evaluated on Amazon EC2 instances across different geographic locations, demonstrating robustness under varying network conditions. The work provides important insights for optimizing real-time image classification on resource-constrained edge devices handling distorted inputs.\\narXiv ID: 2111.14243v1, Summary: EffCNet is an efficient version of CondenseNet designed for edge devices, utilizing depthwise separable convolutions and self-querying data augmentation to improve real-time inference performance. The paper demonstrates significant reductions in model size (from 16.7MB to 2.1MB for CIFAR-10), FLOPs (from 65.82M to 61.01M), and parameters while maintaining competitive accuracy (94.15% top-1 on CIFAR-10). The architecture was successfully deployed on NXP BlueBox 2.0, an edge platform for autonomous vehicles, showing practical applicability for resource-constrained environments.\\narXiv ID: 2502.10047v1, Summary: This paper presents Janus, a novel framework for low-latency cloud-device collaborative Vision Transformer (ViT) inference over dynamic networks. The key innovation is combining token pruning techniques with a fine-to-coarse model splitting policy to enable efficient ViT execution across edge and cloud resources. Janus dynamically selects optimal pruning levels and split points based on network conditions, achieving up to 5.15x throughput improvement and reducing latency violations by up to 98.7% compared to baselines while maintaining accuracy. The system includes a lightweight profiler for latency prediction and a dynamic scheduler for real-time configuration. Experimental results demonstrate Janus\\'s effectiveness across image recognition and video classification tasks under various network conditions.\\narXiv ID: 2404.10407v1, Summary: This comprehensive survey paper evaluates four primary model compression techniques (quantization, low-rank approximation, knowledge distillation, and pruning) for optimizing Vision Transformers (ViTs) for edge deployment. Through extensive experiments on CIFAR datasets, the authors demonstrate that post-training quantization and knowledge distillation achieve the best trade-offs, reducing model size by 4x while maintaining accuracy. The paper also explores hybrid approaches, showing that combining quantization with knowledge distillation can double inference speed while reducing model size to 25% of original. Key findings include: 1) Dynamic quantization reduces ViT size to 84MB (from 327MB) with minimal accuracy drop (98.73% vs 98.94% on CIFAR-10), 2) DeiT tiny achieves 16.78 iterations/sec (vs 4.48 for vanilla ViT) with 95.43% accuracy, and 3) Hybrid approaches combining quantization and distillation achieve 2x speedup with manageable accuracy trade-offs.\\narXiv ID: 2303.08810v1, Summary: BiFormer introduces a novel bi-level routing attention (BRA) mechanism for vision transformers that enables dynamic, query-aware sparsity. BRA first filters irrelevant key-value pairs at a coarse region level (region-to-region routing) before applying fine-grained token-to-token attention in the remaining regions. This approach achieves O((HW)^(4/3)) complexity with proper region partitioning while maintaining global receptive fields. The authors demonstrate state-of-the-art performance on ImageNet classification (83.8% top-1 accuracy for BiFormer-S), COCO object detection (47.1 mAP for BiFormer-B), and ADE20K semantic segmentation (49.9 mIoU for BiFormer-B). The method shows particular strength in preserving fine-grained details for small object detection, with BiFormer-S achieving 30.2 APs on COCO compared to 29.2 for WaveViT-S.\\narXiv ID: 2212.02687v3, Summary: This paper investigates dynamic inference techniques for vision transformers to enable efficient execution under varying resource constraints. Key findings include: (1) Convolutions dominate FLOPs in modern vision transformers (68-89%), not attention layers, due to integrated convolutions for accuracy/performance. (2) FLOP distribution poorly predicts GPU runtime due to optimized convolution execution. (3) Models show varying resilience to pruning - SegFormer achieves 28% energy savings with 1.4% accuracy drop without retraining, while ResNet-50 (via OFA) achieves 53% energy savings with 3.3% accuracy drop. The work provides insights for designing efficient vision transformers and dynamic execution strategies for edge deployment.\\narXiv ID: 2405.00906v1, Summary: LOTUS introduces a novel method combining data lottery ticket selection and sparsity pruning to accelerate vision transformer training while maintaining accuracy. The approach identifies informative data subsets and eliminates redundant parameters through a three-phase process: (1) attention-map-based data lottery ticket identification, (2) Instant Sparse Soup Pruning (ISSP) for model compression, and (3) fine-tuning. Experiments show rapid convergence (reaching near-SOTA performance by 5 epochs) and maintain 79% accuracy at 30% sparsity on CIFAR-10, though ISSP showed accuracy drops due to aggressive pruning. The work demonstrates promising directions for efficient transformer training through combined data and model optimization.\\narXiv ID: 2111.15667v3, Summary: This paper introduces Adaptive Token Sampler (ATS), a parameter-free module for dynamically reducing the number of tokens in vision transformers based on input content. ATS uses attention weights to score token importance and performs inverse transform sampling to select significant tokens. Key results: 1) Reduces DeiT-S GFLOPs by 37% with only 0.1% accuracy drop on ImageNet; 2) Achieves 2x computational cost reduction while preserving accuracy on Kinetics-400/600; 3) Can be added to pre-trained models without fine-tuning. The method shows superior efficiency-accuracy trade-offs compared to DynamicViT and EViT.\\narXiv ID: 2408.08437v1, Summary: This paper presents PQV-Mobile, a combined pruning and quantization toolkit for optimizing Vision Transformers (ViTs) for mobile/edge deployment. Key contributions: 1) Supports multiple structured pruning methods (magnitude, Taylor, Hessian importance) and quantization (FP32 to FP16/int8); 2) Achieves 7.18x latency reduction with only 2.24% accuracy drop on DeiT models; 3) Provides hardware-aware optimizations for various backends (x86, FBGEMM, QNNPACK). Experimental results show superior latency-memory-accuracy tradeoffs compared to standalone compression methods.\\nPlan: Research Plan: "Adaptive Token-Head Co-Optimization for Edge ViTs" (ATHE)\\n\\n1. Novel Technique: \\n- Combines input-aware token pruning (ATS-like) with dynamic attention head routing\\n- Two-stage adaptation: (1) Lightweight CNN classifier categorizes input difficulty (simple/complex), (2) ViT dynamically adjusts:\\n   * Simple images: Aggressive token pruning (50-70%) + only basic attention heads\\n   * Complex images: Conservative pruning (20-30%) + all specialized heads\\n\\n2. Implementation:\\n- Base Model: DeiT-Tiny (5.7M params) modified with:\\n   * Input classifier (MobileNetV1 0.25x width)\\n   * Token importance scoring (learned linear layer)\\n   * Head importance scoring (attention entropy-based)\\n- Device: Raspberry Pi 4 (4GB) with PyTorch Lite\\n- Dataset: CIFAR-100 (resized to 224x224)\\n\\n3. Experiment:\\n- Baseline Comparisons: \\n   * Vanilla DeiT-Tiny\\n   * DynamicViT (token pruning only)\\n   * BiFormer (static sparse attention)\\n- Metrics:\\n   * Accuracy (top-1)\\n   * Latency (end-to-end inference)\\n   * Energy (measured via USB power monitor)\\n   * FLOPs reduction\\n- Evaluation Protocol:\\n   * 5 runs per configuration\\n   * Test on balanced subset (500 simple/complex images each)\\n\\n4. Expected Innovations:\\n- First joint optimization of tokens and heads based on input content\\n- Hardware-friendly implementation (minimal overhead for adaptation logic)\\n- Demonstrable 2-3x latency reduction vs baselines for simple images\\n\\n5. Timeline:\\nWeek 1-2: Model modifications\\nWeek 3: Baseline implementations\\nWeek 4: Profiling/measurements\\nWeek 5: Analysis/writeup', 'Current Plan: Research Plan: "Adaptive Token-Head Co-Optimization for Edge ViTs" (ATHE)\\n\\n1. Novel Technique: \\n- Combines input-aware token pruning (ATS-like) with dynamic attention head routing\\n- Two-stage adaptation: (1) Lightweight CNN classifier categorizes input difficulty (simple/complex), (2) ViT dynamically adjusts:\\n   * Simple images: Aggressive token pruning (50-70%) + only basic attention heads\\n   * Complex images: Conservative pruning (20-30%) + all specialized heads\\n\\n2. Implementation:\\n- Base Model: DeiT-Tiny (5.7M params) modified with:\\n   * Input classifier (MobileNetV1 0.25x width)\\n   * Token importance scoring (learned linear layer)\\n   * Head importance scoring (attention entropy-based)\\n- Device: Raspberry Pi 4 (4GB) with PyTorch Lite\\n- Dataset: CIFAR-100 (resized to 224x224)\\n\\n3. Experiment:\\n- Baseline Comparisons: \\n   * Vanilla DeiT-Tiny\\n   * DynamicViT (token pruning only)\\n   * BiFormer (static sparse attention)\\n- Metrics:\\n   * Accuracy (top-1)\\n   * Latency (end-to-end inference)\\n   * Energy (measured via USB power monitor)\\n   * FLOPs reduction\\n- Evaluation Protocol:\\n   * 5 runs per configuration\\n   * Test on balanced subset (500 simple/complex images each)\\n\\n4. Expected Innovations:\\n- First joint optimization of tokens and heads based on input content\\n- Hardware-friendly implementation (minimal overhead for adaptation logic)\\n- Demonstrable 2-3x latency reduction vs baselines for simple images\\n\\n5. Timeline:\\nWeek 1-2: Model modifications\\nWeek 3: Baseline implementations\\nWeek 4: Profiling/measurements\\nWeek 5: Analysis/writeup')\n~~~~~~~~~~\nHistory: Step #0, Phase: data preparation, Feedback: \nFeedback from previous command: \n, Your response: ```DIALOGUE\nLet's start by loading the CIFAR-100 dataset from HuggingFace as specified in the plan. We'll need to resize the images to 224x224 for DeiT compatibility. Would you like me to proceed with loading and resizing the dataset using a simple pipeline?\n```\nStep #1, Phase: data preparation, Feedback: \nFeedback from previous command: \nHF search command produced by the ML agent:\nCIFAR-100Feedback provided to the ML agent: Huggingface results: Dataset ID: cifar100\nDescription: The CIFAR-100 dataset consists of 60000 32x32 colour images in 100 classes, with 600 images\nper class. There are 500 training images and 100 testing images per class. There are 50000 training images and 10000 test images. The 100 classes are grouped into 20 superclasses.\nThere are two labels per image - fine label (actual class) and coarse label (superclass).\nLikes: 6\nDownloads: 3516\nHas Testing Set: True\nHas Training Set: True\nTest Download Size: 21.6M\nTest Dataset Size: 10000\nTrain Download Size: 107.5M\nTrain Dataset Size: 50000\n\nDataset ID: opus100\nDescription: OPUS-100 is English-centric, meaning that all training pairs include English on either the source or target side.\nThe corpus covers 100 languages (including English).OPUS-100 contains approximately 55M sentence pairs.\nOf the 99 language pairs, 44 have 1M sentence pairs of training data, 73 have at least 100k, and 95 have at least 10k.\nLikes: 19\nDownloads: 19200\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: cifar10\nDescription: The CIFAR-10 dataset consists of 60000 32x32 colour images in 10 classes, with 6000 images\nper class. There are 50000 training images and 10000 test images.\nLikes: 14\nDownloads: 23528\nHas Testing Set: True\nHas Training Set: True\nTest Download Size: 21.7M\nTest Dataset Size: 10000\nTrain Download Size: 108.6M\nTrain Dataset Size: 50000\n\nDataset ID: wikitext\nDescription:  The WikiText language modeling dataset is a collection of over 100 million tokens extracted from the set of verified\n Good and Featured articles on Wikipedia. The dataset is available under the Creative Commons Attribution-ShareAlike\n License.\nLikes: 116\nDownloads: 275669\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: race\nDescription: Race is a large-scale reading comprehension dataset with more than 28,000 passages and nearly 100,000 questions. The\n dataset is collected from English examinations in China, which are designed for middle school and high school students.\nThe dataset can be served as the training and test sets for machine comprehension.\nLikes: 14\nDownloads: 46623\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: google_wellformed_query\nDescription: Google's query wellformedness dataset was created by crowdsourcing well-formedness annotations for 25,100 queries from the Paralex corpus. Every query was annotated by five raters each with 1/0 rating of whether or not the query is well-formed.\nLikes: 5\nDownloads: 1036\nHas Testing Set: True\nHas Training Set: True\nTest Download Size: 185.1K\nTest Dataset Size: 3850\nTrain Download Size: 837.3K\nTrain Dataset Size: 17500\n\nDataset ID: wiki_dpr\nDescription: This is the wikipedia split used to evaluate the Dense Passage Retrieval (DPR) model.\nIt contains 21M passages from wikipedia along with their DPR embeddings.\nThe wikipedia articles were split into multiple, disjoint text blocks of 100 words as passages.\nLikes: 11\nDownloads: 6942\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: squad_v2\nDescription: combines the 100,000 questions in SQuAD1.1 with over 50,000 unanswerable questions written adversarially by crowdworkers\n to look similar to answerable ones. To do well on SQuAD2.0, systems must not only answer questions when possible, but\n also determine when no answer is supported by the paragraph and abstain from answering.\nLikes: 27\nDownloads: 41619\nHas Testing Set: False\nHas Training Set: True\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: 111.3M\nTrain Dataset Size: 130319\n\nDataset ID: alkzar90/NIH-Chest-X-ray-dataset\nDescription: The NIH Chest X-ray dataset consists of 100,000 de-identified images of chest x-rays. The images are in PNG format.\n\nThe data is provided by the NIH Clinical Center and is available through the NIH download site: https://nihcc.app.box.com/v/ChestXray-NIHCC\nLikes: 9\nDownloads: 52\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: ubuntu_dialogs_corpus\nDescription: Ubuntu Dialogue Corpus, a dataset containing almost 1 million multi-turn dialogues, with a total of over 7 million utterances and 100 million words. This provides a unique resource for research into building dialogue managers based on neural language models that can make use of large amounts of unlabeled data. The dataset has both the multi-turn property of conversations in the Dialog State Tracking Challenge datasets, and the unstructured nature of interactions from microblog services such as Twitter.\nLikes: 8\nDownloads: 441\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\n, Your response: ```SUBMIT_CODE\nfrom datasets import load_dataset\nimport torchvision.transforms as transforms\n\n# Load CIFAR-100 dataset\ndataset = load_dataset("cifar100")\n\n# Define transform to resize images to 224x224 and normalize\ntransform = transforms.Compose([\n    transforms.Resize((224, 224)),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])\n])\n\n# Apply transform to both train and test sets\ndataset["train"] = dataset["train"].map(lambda x: {"img": transform(x["img"])})\ndataset["test"] = dataset["test"].map(lambda x: {"img": transform(x["img"])})\n```\n~~~~~~~~~~\nCurrent Step #2, Phase: data preparation\n\n[Objective] Your goal is to perform research on the following topic: The goal is to design and evaluate a new technique for optimizing deep learning models for real-time image classification on resource-constrained edge devices, aiming to maximize accuracy while minimizing inference latency and power consumption.\nFeedback: \nFeedback from previous command: \nCode Response: [CODE EXECUTION ERROR]: Code execution exceeded the timeout limit of 60 seconds. You must reduce the time complexity of your code.\n\nERROR: Final code had an error and could not be submitted! You must address and fix this error.\n\nCode produced by the ML agent:\n\nfrom datasets import load_dataset\nimport torchvision.transforms as transforms\n\n# Load CIFAR-100 dataset\ndataset = load_dataset("cifar100")\n\n# Define transforms to resize images to 224x224 for DeiT compatibility\ntransform = transforms.Compose([\n    transforms.Resize((224, 224)),\n    transforms.ToTensor()\n])\n\n# Apply transforms to both train and test sets\ndataset = dataset.map(lambda x: {"image": transform(x["img"])}, batched=False)\nprint("CIFAR-100 dataset loaded and resized to 224x224")\nprint(f"Train samples: {len(dataset['train'])}, Test samples: {len(dataset['test'])}")Feedback provided to the ML agent: \nCode Response: [CODE EXECUTION ERROR]: Code execution exceeded the timeout limit of 120 seconds. You must reduce the time complexity of your code.\n\nNotes: Notes for the task objective: [{'phases': ['data preparation'], 'note': 'Use a public, well-documented dataset for image classification, suitable for experimentation on edge devices (e.g. CIFAR-10, or a reduced/adapted version of a larger dataset).'}, {'phases': ['data preparation'], 'note': 'Describe all preprocessing and data augmentation steps necessary to improve training efficiency or inference quality on edge devices.'}, {'phases': ['data preparation'], 'note': 'Here is a sample code you can use to load CIFAR-10\\\\nfrom datasets import load_dataset\\\\ncifar10_test_set = load_dataset("cifar10")["test"]\\\\n# Para carregar o conjunto de treino, voc\xc3\xaa usaria:\\\\n# cifar10_train_set = load_dataset("cifar10")["train"]'}]\n\nYour previous command was: ```SUBMIT_CODE\nfrom datasets import load_dataset\nimport torchvision.transforms as transforms\n\n# Load CIFAR-100 dataset\ndataset = load_dataset("cifar100")\n\n# Define transform to resize images to 224x224 and normalize\ntransform = transforms.Compose([\n    transforms.Resize((224, 224)),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])\n])\n\n# Apply transform to both train and test sets\ndataset["train"] = dataset["train"].map(lambda x: {"img": transform(x["img"])})\ndataset["test"] = dataset["test"].map(lambda x: {"img": transform(x["img"])})\n```. Make sure your new output is very different.\nPlease produce a single command below:\n
==================================================
Interaction 4:
('', 'Current Literature Review: Provided here is a literature review on this topic:\\narXiv ID: 2011.14808v1, Summary: This comprehensive survey paper discusses deep learning optimization techniques for edge computing systems. It covers four main approaches: (1) hand-crafted lightweight models like MobileNet and EfficientNet, (2) model compression methods including pruning and quantization, (3) hardware-aware neural architecture search, and (4) adaptive deep learning models. The paper provides detailed comparisons of different techniques and their tradeoffs between accuracy and efficiency. Experimental results show these optimization methods can significantly reduce model size and computational complexity while maintaining competitive accuracy, making them suitable for resource-constrained edge devices.\\narXiv ID: 2108.09343v2, Summary: This paper proposes an early-exit DNN architecture with expert branches specialized for different image distortion types (blur and noise) to improve edge offloading efficiency. The key innovation is using a distortion classifier to select appropriate expert branches at each exit point, enabling more accurate early classification on edge devices. Experiments show the approach increases edge classification probability by 10-20% for distorted images while maintaining accuracy, reducing end-to-end latency by up to 30% compared to standard early-exit DNNs. The method is evaluated on Amazon EC2 instances across different geographic locations, demonstrating robustness under varying network conditions. The work provides important insights for optimizing real-time image classification on resource-constrained edge devices handling distorted inputs.\\narXiv ID: 2111.14243v1, Summary: EffCNet is an efficient version of CondenseNet designed for edge devices, utilizing depthwise separable convolutions and self-querying data augmentation to improve real-time inference performance. The paper demonstrates significant reductions in model size (from 16.7MB to 2.1MB for CIFAR-10), FLOPs (from 65.82M to 61.01M), and parameters while maintaining competitive accuracy (94.15% top-1 on CIFAR-10). The architecture was successfully deployed on NXP BlueBox 2.0, an edge platform for autonomous vehicles, showing practical applicability for resource-constrained environments.\\narXiv ID: 2502.10047v1, Summary: This paper presents Janus, a novel framework for low-latency cloud-device collaborative Vision Transformer (ViT) inference over dynamic networks. The key innovation is combining token pruning techniques with a fine-to-coarse model splitting policy to enable efficient ViT execution across edge and cloud resources. Janus dynamically selects optimal pruning levels and split points based on network conditions, achieving up to 5.15x throughput improvement and reducing latency violations by up to 98.7% compared to baselines while maintaining accuracy. The system includes a lightweight profiler for latency prediction and a dynamic scheduler for real-time configuration. Experimental results demonstrate Janus\\'s effectiveness across image recognition and video classification tasks under various network conditions.\\narXiv ID: 2404.10407v1, Summary: This comprehensive survey paper evaluates four primary model compression techniques (quantization, low-rank approximation, knowledge distillation, and pruning) for optimizing Vision Transformers (ViTs) for edge deployment. Through extensive experiments on CIFAR datasets, the authors demonstrate that post-training quantization and knowledge distillation achieve the best trade-offs, reducing model size by 4x while maintaining accuracy. The paper also explores hybrid approaches, showing that combining quantization with knowledge distillation can double inference speed while reducing model size to 25% of original. Key findings include: 1) Dynamic quantization reduces ViT size to 84MB (from 327MB) with minimal accuracy drop (98.73% vs 98.94% on CIFAR-10), 2) DeiT tiny achieves 16.78 iterations/sec (vs 4.48 for vanilla ViT) with 95.43% accuracy, and 3) Hybrid approaches combining quantization and distillation achieve 2x speedup with manageable accuracy trade-offs.\\narXiv ID: 2303.08810v1, Summary: BiFormer introduces a novel bi-level routing attention (BRA) mechanism for vision transformers that enables dynamic, query-aware sparsity. BRA first filters irrelevant key-value pairs at a coarse region level (region-to-region routing) before applying fine-grained token-to-token attention in the remaining regions. This approach achieves O((HW)^(4/3)) complexity with proper region partitioning while maintaining global receptive fields. The authors demonstrate state-of-the-art performance on ImageNet classification (83.8% top-1 accuracy for BiFormer-S), COCO object detection (47.1 mAP for BiFormer-B), and ADE20K semantic segmentation (49.9 mIoU for BiFormer-B). The method shows particular strength in preserving fine-grained details for small object detection, with BiFormer-S achieving 30.2 APs on COCO compared to 29.2 for WaveViT-S.\\narXiv ID: 2212.02687v3, Summary: This paper investigates dynamic inference techniques for vision transformers to enable efficient execution under varying resource constraints. Key findings include: (1) Convolutions dominate FLOPs in modern vision transformers (68-89%), not attention layers, due to integrated convolutions for accuracy/performance. (2) FLOP distribution poorly predicts GPU runtime due to optimized convolution execution. (3) Models show varying resilience to pruning - SegFormer achieves 28% energy savings with 1.4% accuracy drop without retraining, while ResNet-50 (via OFA) achieves 53% energy savings with 3.3% accuracy drop. The work provides insights for designing efficient vision transformers and dynamic execution strategies for edge deployment.\\narXiv ID: 2405.00906v1, Summary: LOTUS introduces a novel method combining data lottery ticket selection and sparsity pruning to accelerate vision transformer training while maintaining accuracy. The approach identifies informative data subsets and eliminates redundant parameters through a three-phase process: (1) attention-map-based data lottery ticket identification, (2) Instant Sparse Soup Pruning (ISSP) for model compression, and (3) fine-tuning. Experiments show rapid convergence (reaching near-SOTA performance by 5 epochs) and maintain 79% accuracy at 30% sparsity on CIFAR-10, though ISSP showed accuracy drops due to aggressive pruning. The work demonstrates promising directions for efficient transformer training through combined data and model optimization.\\narXiv ID: 2111.15667v3, Summary: This paper introduces Adaptive Token Sampler (ATS), a parameter-free module for dynamically reducing the number of tokens in vision transformers based on input content. ATS uses attention weights to score token importance and performs inverse transform sampling to select significant tokens. Key results: 1) Reduces DeiT-S GFLOPs by 37% with only 0.1% accuracy drop on ImageNet; 2) Achieves 2x computational cost reduction while preserving accuracy on Kinetics-400/600; 3) Can be added to pre-trained models without fine-tuning. The method shows superior efficiency-accuracy trade-offs compared to DynamicViT and EViT.\\narXiv ID: 2408.08437v1, Summary: This paper presents PQV-Mobile, a combined pruning and quantization toolkit for optimizing Vision Transformers (ViTs) for mobile/edge deployment. Key contributions: 1) Supports multiple structured pruning methods (magnitude, Taylor, Hessian importance) and quantization (FP32 to FP16/int8); 2) Achieves 7.18x latency reduction with only 2.24% accuracy drop on DeiT models; 3) Provides hardware-aware optimizations for various backends (x86, FBGEMM, QNNPACK). Experimental results show superior latency-memory-accuracy tradeoffs compared to standalone compression methods.\\nPlan: Research Plan: "Adaptive Token-Head Co-Optimization for Edge ViTs" (ATHE)\\n\\n1. Novel Technique: \\n- Combines input-aware token pruning (ATS-like) with dynamic attention head routing\\n- Two-stage adaptation: (1) Lightweight CNN classifier categorizes input difficulty (simple/complex), (2) ViT dynamically adjusts:\\n   * Simple images: Aggressive token pruning (50-70%) + only basic attention heads\\n   * Complex images: Conservative pruning (20-30%) + all specialized heads\\n\\n2. Implementation:\\n- Base Model: DeiT-Tiny (5.7M params) modified with:\\n   * Input classifier (MobileNetV1 0.25x width)\\n   * Token importance scoring (learned linear layer)\\n   * Head importance scoring (attention entropy-based)\\n- Device: Raspberry Pi 4 (4GB) with PyTorch Lite\\n- Dataset: CIFAR-100 (resized to 224x224)\\n\\n3. Experiment:\\n- Baseline Comparisons: \\n   * Vanilla DeiT-Tiny\\n   * DynamicViT (token pruning only)\\n   * BiFormer (static sparse attention)\\n- Metrics:\\n   * Accuracy (top-1)\\n   * Latency (end-to-end inference)\\n   * Energy (measured via USB power monitor)\\n   * FLOPs reduction\\n- Evaluation Protocol:\\n   * 5 runs per configuration\\n   * Test on balanced subset (500 simple/complex images each)\\n\\n4. Expected Innovations:\\n- First joint optimization of tokens and heads based on input content\\n- Hardware-friendly implementation (minimal overhead for adaptation logic)\\n- Demonstrable 2-3x latency reduction vs baselines for simple images\\n\\n5. Timeline:\\nWeek 1-2: Model modifications\\nWeek 3: Baseline implementations\\nWeek 4: Profiling/measurements\\nWeek 5: Analysis/writeup', 'Current Plan: Research Plan: "Adaptive Token-Head Co-Optimization for Edge ViTs" (ATHE)\\n\\n1. Novel Technique: \\n- Combines input-aware token pruning (ATS-like) with dynamic attention head routing\\n- Two-stage adaptation: (1) Lightweight CNN classifier categorizes input difficulty (simple/complex), (2) ViT dynamically adjusts:\\n   * Simple images: Aggressive token pruning (50-70%) + only basic attention heads\\n   * Complex images: Conservative pruning (20-30%) + all specialized heads\\n\\n2. Implementation:\\n- Base Model: DeiT-Tiny (5.7M params) modified with:\\n   * Input classifier (MobileNetV1 0.25x width)\\n   * Token importance scoring (learned linear layer)\\n   * Head importance scoring (attention entropy-based)\\n- Device: Raspberry Pi 4 (4GB) with PyTorch Lite\\n- Dataset: CIFAR-100 (resized to 224x224)\\n\\n3. Experiment:\\n- Baseline Comparisons: \\n   * Vanilla DeiT-Tiny\\n   * DynamicViT (token pruning only)\\n   * BiFormer (static sparse attention)\\n- Metrics:\\n   * Accuracy (top-1)\\n   * Latency (end-to-end inference)\\n   * Energy (measured via USB power monitor)\\n   * FLOPs reduction\\n- Evaluation Protocol:\\n   * 5 runs per configuration\\n   * Test on balanced subset (500 simple/complex images each)\\n\\n4. Expected Innovations:\\n- First joint optimization of tokens and heads based on input content\\n- Hardware-friendly implementation (minimal overhead for adaptation logic)\\n- Demonstrable 2-3x latency reduction vs baselines for simple images\\n\\n5. Timeline:\\nWeek 1-2: Model modifications\\nWeek 3: Baseline implementations\\nWeek 4: Profiling/measurements\\nWeek 5: Analysis/writeup')\n~~~~~~~~~~\nHistory: Step #0, Phase: data preparation, Feedback: \nFeedback from previous command: \n, Your response: ```DIALOGUE\nLet's start by loading the CIFAR-100 dataset from HuggingFace as specified in the plan. We'll need to resize the images to 224x224 for DeiT compatibility. Would you like me to proceed with loading and resizing the dataset using a simple pipeline?\n```\nStep #1, Phase: data preparation, Feedback: \nFeedback from previous command: \nHF search command produced by the ML agent:\nCIFAR-100Feedback provided to the ML agent: Huggingface results: Dataset ID: cifar100\nDescription: The CIFAR-100 dataset consists of 60000 32x32 colour images in 100 classes, with 600 images\nper class. There are 500 training images and 100 testing images per class. There are 50000 training images and 10000 test images. The 100 classes are grouped into 20 superclasses.\nThere are two labels per image - fine label (actual class) and coarse label (superclass).\nLikes: 6\nDownloads: 3516\nHas Testing Set: True\nHas Training Set: True\nTest Download Size: 21.6M\nTest Dataset Size: 10000\nTrain Download Size: 107.5M\nTrain Dataset Size: 50000\n\nDataset ID: opus100\nDescription: OPUS-100 is English-centric, meaning that all training pairs include English on either the source or target side.\nThe corpus covers 100 languages (including English).OPUS-100 contains approximately 55M sentence pairs.\nOf the 99 language pairs, 44 have 1M sentence pairs of training data, 73 have at least 100k, and 95 have at least 10k.\nLikes: 19\nDownloads: 19200\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: cifar10\nDescription: The CIFAR-10 dataset consists of 60000 32x32 colour images in 10 classes, with 6000 images\nper class. There are 50000 training images and 10000 test images.\nLikes: 14\nDownloads: 23528\nHas Testing Set: True\nHas Training Set: True\nTest Download Size: 21.7M\nTest Dataset Size: 10000\nTrain Download Size: 108.6M\nTrain Dataset Size: 50000\n\nDataset ID: wikitext\nDescription:  The WikiText language modeling dataset is a collection of over 100 million tokens extracted from the set of verified\n Good and Featured articles on Wikipedia. The dataset is available under the Creative Commons Attribution-ShareAlike\n License.\nLikes: 116\nDownloads: 275669\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: race\nDescription: Race is a large-scale reading comprehension dataset with more than 28,000 passages and nearly 100,000 questions. The\n dataset is collected from English examinations in China, which are designed for middle school and high school students.\nThe dataset can be served as the training and test sets for machine comprehension.\nLikes: 14\nDownloads: 46623\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: google_wellformed_query\nDescription: Google's query wellformedness dataset was created by crowdsourcing well-formedness annotations for 25,100 queries from the Paralex corpus. Every query was annotated by five raters each with 1/0 rating of whether or not the query is well-formed.\nLikes: 5\nDownloads: 1036\nHas Testing Set: True\nHas Training Set: True\nTest Download Size: 185.1K\nTest Dataset Size: 3850\nTrain Download Size: 837.3K\nTrain Dataset Size: 17500\n\nDataset ID: wiki_dpr\nDescription: This is the wikipedia split used to evaluate the Dense Passage Retrieval (DPR) model.\nIt contains 21M passages from wikipedia along with their DPR embeddings.\nThe wikipedia articles were split into multiple, disjoint text blocks of 100 words as passages.\nLikes: 11\nDownloads: 6942\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: squad_v2\nDescription: combines the 100,000 questions in SQuAD1.1 with over 50,000 unanswerable questions written adversarially by crowdworkers\n to look similar to answerable ones. To do well on SQuAD2.0, systems must not only answer questions when possible, but\n also determine when no answer is supported by the paragraph and abstain from answering.\nLikes: 27\nDownloads: 41619\nHas Testing Set: False\nHas Training Set: True\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: 111.3M\nTrain Dataset Size: 130319\n\nDataset ID: alkzar90/NIH-Chest-X-ray-dataset\nDescription: The NIH Chest X-ray dataset consists of 100,000 de-identified images of chest x-rays. The images are in PNG format.\n\nThe data is provided by the NIH Clinical Center and is available through the NIH download site: https://nihcc.app.box.com/v/ChestXray-NIHCC\nLikes: 9\nDownloads: 52\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\nDataset ID: ubuntu_dialogs_corpus\nDescription: Ubuntu Dialogue Corpus, a dataset containing almost 1 million multi-turn dialogues, with a total of over 7 million utterances and 100 million words. This provides a unique resource for research into building dialogue managers based on neural language models that can make use of large amounts of unlabeled data. The dataset has both the multi-turn property of conversations in the Dialog State Tracking Challenge datasets, and the unstructured nature of interactions from microblog services such as Twitter.\nLikes: 8\nDownloads: 441\nHas Testing Set: False\nHas Training Set: False\nTest Download Size: None\nTest Dataset Size: None\nTrain Download Size: None\nTrain Dataset Size: None\n\n, Your response: ```SUBMIT_CODE\nfrom datasets import load_dataset\nimport torchvision.transforms as transforms\n\n# Load CIFAR-100 dataset\ndataset = load_dataset("cifar100")\n\n# Define transform to resize images to 224x224 and normalize\ntransform = transforms.Compose([\n    transforms.Resize((224, 224)),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])\n])\n\n# Apply transform to both train and test sets\ndataset["train"] = dataset["train"].map(lambda x: {"img": transform(x["img"])})\ndataset["test"] = dataset["test"].map(lambda x: {"img": transform(x["img"])})\n```\nStep #2, Phase: data preparation, Feedback: \nFeedback from previous command: \nCode Response: [CODE EXECUTION ERROR]: Code execution exceeded the timeout limit of 60 seconds. You must reduce the time complexity of your code.\n\nERROR: Final code had an error and could not be submitted! You must address and fix this error.\n\nCode produced by the ML agent:\n\nfrom datasets import load_dataset\nimport torchvision.transforms as transforms\n\n# Load CIFAR-100 dataset\ndataset = load_dataset("cifar100")\n\n# Define transforms to resize images to 224x224 for DeiT compatibility\ntransform = transforms.Compose([\n    transforms.Resize((224, 224)),\n    transforms.ToTensor()\n])\n\n# Apply transforms to both train and test sets\ndataset = dataset.map(lambda x: {"image": transform(x["img"])}, batched=False)\nprint("CIFAR-100 dataset loaded and resized to 224x224")\nprint(f"Train samples: {len(dataset['train'])}, Test samples: {len(dataset['test'])}")Feedback provided to the ML agent: \nCode Response: [CODE EXECUTION ERROR]: Code execution exceeded the timeout limit of 120 seconds. You must reduce the time complexity of your code.\n, Your response: ```DIALOGUE\nLet's try a simpler approach - we'll load just the test set of CIFAR-100 first (which is smaller) and apply the transforms in a batched manner to improve efficiency. Would you like me to proceed with this optimized version?\n```\n~~~~~~~~~~\nCurrent Step #3, Phase: data preparation\n\n[Objective] Your goal is to perform research on the following topic: The goal is to design and evaluate a new technique for optimizing deep learning models for real-time image classification on resource-constrained edge devices, aiming to maximize accuracy while minimizing inference latency and power consumption.\nFeedback: \nFeedback from previous command: \nCode produced by the ML agent:\n\nfrom datasets import load_dataset\nimport torchvision.transforms as transforms\n\n# Load only CIFAR-100 test set with batched transforms\ntest_set = load_dataset("cifar100", split="test")\n\n# Define batched transform function\ndef transform_batch(batch):\n    transform = transforms.Compose([\n        transforms.Resize((224, 224)),\n        transforms.ToTensor()\n    ])\n    batch["image"] = [transform(img) for img in batch["img"]]\n    return batch\n\n# Apply transforms in batches of 100\ntest_set = test_set.map(transform_batch, batched=True, batch_size=100)\nprint(f"Successfully loaded and transformed {len(test_set)} test samples")Feedback provided to the ML agent: \nCode Response: [CODE EXECUTION ERROR]: Code execution exceeded the timeout limit of 120 seconds. You must reduce the time complexity of your code.\n\nNotes: Notes for the task objective: [{'phases': ['data preparation'], 'note': 'Use a public, well-documented dataset for image classification, suitable for experimentation on edge devices (e.g. CIFAR-10, or a reduced/adapted version of a larger dataset).'}, {'phases': ['data preparation'], 'note': 'Describe all preprocessing and data augmentation steps necessary to improve training efficiency or inference quality on edge devices.'}, {'phases': ['data preparation'], 'note': 'Here is a sample code you can use to load CIFAR-10\\\\nfrom datasets import load_dataset\\\\ncifar10_test_set = load_dataset("cifar10")["test"]\\\\n# Para carregar o conjunto de treino, voc\xc3\xaa usaria:\\\\n# cifar10_train_set = load_dataset("cifar10")["train"]'}]\n\nYour previous command was: ```DIALOGUE\nLet's try a simpler approach - we'll load just the test set of CIFAR-100 first (which is smaller) and apply the transforms in a batched manner to improve efficiency. Would you like me to proceed with this optimized version?\n```. Make sure your new output is very different.\nPlease produce a single command below:\n
==================================================


=== SW_ENGINEER RESPONSE LOG ===

Interaction 1:
```DIALOGUE
Let's start by loading the CIFAR-100 dataset from HuggingFace as specified in the plan. We'll need to resize the images to 224x224 for DeiT compatibility. Would you like me to proceed with loading and resizing the dataset using a simple pipeline?
```
==================================================
Interaction 2:
```SUBMIT_CODE
from datasets import load_dataset
import torchvision.transforms as transforms

# Load CIFAR-100 dataset
dataset = load_dataset("cifar100")

# Define transform to resize images to 224x224 and normalize
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# Apply transform to both train and test sets
dataset["train"] = dataset["train"].map(lambda x: {"img": transform(x["img"])})
dataset["test"] = dataset["test"].map(lambda x: {"img": transform(x["img"])})
```
==================================================
Interaction 3:
```DIALOGUE
Let's try a simpler approach - we'll load just the test set of CIFAR-100 first (which is smaller) and apply the transforms in a batched manner to improve efficiency. Would you like me to proceed with this optimized version?
```
==================================================
Interaction 4:
```SUBMIT_CODE
from datasets import load_dataset
import torchvision.transforms as transforms

# Load only a small subset of CIFAR-100 test set (100 samples)
test_set = load_dataset("cifar100", split="test[:100]")

# Simple transform - just resize to 224x224
transform = transforms.Resize((224, 224))

# Apply transform to each image
test_set = test_set.map(lambda x: {"img": transform(x["img"])})

print(f"Loaded and resized {len(test_set)} samples")
```
==================================================
